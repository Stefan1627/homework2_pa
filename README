# Problema 1

## Descrierea soluției
Pentru a reconstrui un graf neorientat cu N noduri astfel încât distanțele față de nodul 1
să coincidă cu vectorul `v`, am observat că un arbore în care fiecare nod la distanța `d`
este conectat la un nod oarecare de la distanța `d-1` realizează exact condiția cerută.
Astfel:
1. Citim vectorul `v[1..N]`.
2. Verificăm validitatea: 
   - `v[1]` trebuie să fie 0 (nodul 1 este sursa).
   - Pentru orice i>1, `v[i]` nu poate fi 0 (alt nod cu distanța 0 e imposibil).
3. Grupăm nodurile în vectori `byDist[d]` după distanța `d`.
4. Pentru fiecare distanță `d>0` care are noduri, ne asigurăm că există cel puțin
   un nod la distanța `d-1`.
5. Construim muchiile: pentru fiecare nod `u` cu distanța `d`, adăugăm muchia
   `(parent, u)`, unde `parent` e primul nod din `byDist[d-1]`.
6. Dacă vreo condiție de mai sus e încălcată, afișăm `-1`.

## Complexitate
- **Timp:** O(N) pentru citire, grupare, verificări și construire muchii.
- **Memorie:** O(N) pentru vectorii de distanțe și grupare.
- Numărul de muchii rezultat este cel mult N−1, deci respectă cerința de ≤10^6 muchii.

## Considerații adiționale
- Alegerea unui singur părinte la fiecare nivel garantează un arbore (nu cicluri),
  suficient pentru a obține exact distanțele date.
- Soluția detectează rapid (prin verificările pe `byDist`) cazurile imposibile
  fără a construi graful în totaliate.



# Problema 2

## Soluție aleasă
Am aplicat un **sliding-window** peste valorile unice din matrice, astfel:
1. Sortăm și extragem valorile unice `vals[0..U-1]`.
2. Menținem o fereastră de indici `[l, r)` în `vals` astfel încât `vals[r-1] - vals[l] ≤ K`.
3. În fiecare pas, marcăm cu `allow[id] = 1` doar celulele cu valori în fereastră.
4. Pentru fiecare celulă care conține `vals[l]` (valoarea minimă curentă), lansăm un BFS
   flood-fill pentru a determina aria componentei conexe din matricea marcată.
5. Reținem maximul dintre ariile găsite.

Dacă `global_max - global_min ≤ K`, întregul grid este deja o singură zonă.

## Complexitate
- **Timp:**  
  - Sortare + unicat: `O(NM log(NM))`.  
  - Sliding window + BFS-uri: `O(U · NM)` în cel mai rău caz, cu `U ≤ NM`.  
  - Pentru `N,M ≤ 100`, rezultă `NM ≤ 10^4`, iar algoritmul este eficient.
- **Memorie:** `O(NM)` pentru matrice și vectorii auxiliare (`allow`, `seen`, coadă, `pos`).

## Observații
- BFS-ul este implementat cu o coadă statică pentru performanță.
- Verificarea globală (`global_max - global_min`) evită cazul trivial în `O(NM)`.



# Problema 3

## Descrierea soluției
Transformăm situația într-un **graf de stări** în spațiul (timp × poziție pe buștean):
- Fiecărui buștean `i` cu `length[i]+1` poziții `p=0…length[i]` îi corespunde un index plat `s`.
- O stare este un cuplu `(t, s)` = timpul `t` și poziția `s`.
- Tranzițiile de la `(t, s)` la `(t+1, s2)` reprezintă cele trei acțiuni posibile:
  1. **H** (wait): rămâi pe același `s`, cost `E1`.
  2. **N/S/E/V** (pas pe buștean): `s→s±1`, cost `E2`, direcția depinde de orientare.
  3. **J i** (sărit pe alt buștean): de la `(i,p)` la `(j,pj)`, dacă coordonatele absolute coincid, cost `E3`.
- Se calculează poziția absolută `(x,y)` a fiecărei stări prin derivație cumulată a mișcării fiecărui buștean.
- Folosim **programare dinamică** pe timp `dp[t][s]` = energie minimă până la `(t,s)`.
- Rezultatul este minimul `dp[t][s]` pentru orice `t≤T` în care `(x,y)=(target_x,target_y)`.

## Complexitate
- Număr de stări S = Σ(length[i]+1) ≤ O(N·L) (L = lungimea maximă a oricărui buștean).
- DP costă O(T × S × d), unde în
  - fiecare stare relaxăm O(1) pași și O(k) sărituri,
  - k = numărul de bușteni care intersectează o poziție (în medie mic).
- Pentru `N ≤ 80`, `T ≤ 400`, `L ≤ 1000`, soluția rulează în limite (≈10⁷–10⁸ operații).

## Observații
- Am folosit un `unordered_map` pentru a grupa rapid stările care se intersectează la același punct.
- Soluția reconstituie traseul complet, nu doar costul.
- Memoria poate fi redusă ținând doar două straturi de DP (t și t+1), dar aici am păstrat tot `dp` pentru backtracking simplu.
